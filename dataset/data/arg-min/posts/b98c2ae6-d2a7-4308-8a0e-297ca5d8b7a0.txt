<article class="post-content">
<p><em>This is the fifth part of <a href="http://www.argmin.net/outsider-rl.html">“An Outsider’s Tour of Reinforcement Learning.”</a>  Part 6 is <a href="http://www.argmin.net/2018/02/20/reinforce/">here</a>. Part 4 is <a href="http://www.argmin.net/2018/02/08/lqr/">here</a>. Part 1 is <a href="http://www.argmin.net/2018/01/29/taxonomy/">here</a>.</em></p>
<p>The first two parts of this series highlighted two parallel <em>aspirations</em> of the current research in RL: <a href="http://www.argmin.net/2018/01/29/taxonomy/">part 1</a> described reinforcement learning as prescriptive analytics and <a href="http://www.argmin.net/2018/02/01/control-tour/">part 2</a> as optimal control. This post, by contrast, is going to focus on how people typically <em>use</em> RL, both in practice and in papers. The reality of RL is often quite different than the rhetoric, and I want to spend time here to separate the two so it will be easier to understand the limits of different methodologies and algorithms.</p>
<p>There are a set of rules that are abided by, and the rules are agreed upon by loose precedent. I want to delineate these rules and then describe the connections to established inquiries in control system design and analysis.</p>
<h2 id="trajectories-and-policies">Trajectories and Policies</h2>
<p>Let’s begin by revisiting our abstract dynamical system model</p>

\[x_{t+1} = f( x_t, u_t, e_t)\,.\]

<p>Again, $x_t$ is the <em>state</em> of the system, $u_t$ is the control action, and $e_t$ is a random disturbance. We’re going to assume that $f$ is fixed, but unknown.</p>
<p>I will refer to a <em>trajectory</em> as a sequence of states and control actions generated by this dynamical system.</p>

\[\tau_t = (u_1,…,u_{t-1},x_0,…,x_t) \,.\]

<p>A <em>control policy</em> (or simply “a policy”) is a function, $\pi$, that takes a trajectory from a dynamical system and outputs a new control action.  Note that $\pi$ only gets access to previous states and control actions.</p>
<p>For example, in LQR on long time horizons we know that the policy</p>

\[\pi(\tau_t) = K x_t\]

<p>will be nearly optimal for a fixed matrix $K$.  But arbitrarily complicated policies are possible for general RL problems.</p>
<p>Optimal control and reinforcement learning can be equivalently posed as trying to find the policy that maximizes an expected reward.</p>
<h2 id="go-ask-the-oracle">Go ask the oracle</h2>
<p>Recall that our main goal in reinforcement learning is to solve the optimal control problem</p>

\[\begin{array}{ll}
\mbox{maximize}_{u_t} &amp; \mathbb{E}_{e_t}[ \sum_{t=0}^N R_t[x_t,u_t] ]\\
\mbox{subject to} &amp;    x_{t+1} = f(x_t, u_t, e_t)\\
&amp; \mbox{($x_0$ given).}
\end{array}\]

<p>But we assume that we don’t know the function $f$.  Some lines of work even assume that we don’t know the reward function $R$.  I personally feel that not knowing $R$ is unrealistic for any practical problem, and, moreover, that $R$ is actually a design parameter in engineering applications. However, for the purpose of this post, it will make no difference as to whether $R$ is known or unknown.</p>
<p>The important point is that since we can’t solve this optimization problem using standard optimization methods unless we know the function $f$ governing the dynamics. We must learn something about the dynamical system and subsequently choose the best policy based on our knowledge. How do we measure success? We need to balance both the final expected reward of our policy and the number of times we need to interrogate the system to find this policy.</p>
<p>The main paradigm in contemporary RL is to play the following game. We decide on a policy $\pi$ and horizon length L. Then we either pass this policy to a simulation engine or to a real robotic system and are returned a trajectory</p>

\[\tau_L = (u_1,…,u_{L-1},x_0,…,x_L)\,,\]

<p>where $u_t = \pi(\tau_t)$. This is our <em>oracle model</em>. We typically want to minimize the total number of samples computed by the oracle. So if we were to run $m$ queries with horizon length $L$, we would pay a total cost of $mL$.  However, we are free to vary our horizon length for each experiment.</p>
<p>So let’s denote by $n$ the total number of oracle accesses. At the end of the day we want the expected reward to be high for our derived policy, but we also need the number of oracle queries to be small.</p>
<p>Phew. This is already complicated! Note that this framing of the problem makes it very hard to decide on a “best” algorithm. Do we decide an algorithm is best if it achieves some reward in the fewest number of samples?  Or is an algorithm best if it achieves the highest rewards given a fixed budget of samples? Or maybe there’s a middle ground?  I’ll return to such issues about measuring the relative abilities of different RL methods later in this series.</p>
<h2 id="iterative-learning-control">Iterative Learning Control</h2>
<p>Control theorists have a different name for this RL game. They call it <em>iterative learning control</em> (ILC).  In ILC, the focus is on designing control systems that perform a repetitive task, and the design is refined by leveraging repetition. A common example is <a href="http://www.dynsyslab.org/wp-content/papercite-data/pdf/schoellig-ecc09.pdf">learning to track a trajectory</a>, and the input control is improved by adjustment with respect to the deviation from the desired trajectory in previous iterations. ILC is a useful and mature sub-discipline of control theory and has achieved many industrial success stories. Also, it is not an exaggeration to say that the embodiments of iterative learning control in actual physical systems blow any RL demo out of the water.  Here are <a href="https://www.youtube.com/watch?v=4kHDv9senpE">some</a> <a href="https://youtu.be/goVuP5TJIUU">insane</a> <a href="https://www.youtube.com/watch?v=IZTP7h5cfqg">youtubes</a>. Hopefully you’ll come back and read the rest of this post after you get stuck in a rabbit hole of watching mind boggling quadrotor acrobatics.</p>
<p>Iterative learning control and RL merely differ insofar as what information they provide to the control design engineer. In RL, the problems are constructed to hide as much information about the dynamical system as possible. Even though RL practice uses physics simulators that are generated from well-specified differential equations, we have to tie our hands behind our back pretending like we don’t know basic mechanics and that we don’t understand the desired goals of our control system. As a result, RL schemes require millions of training examples to achieve reasonable performance. ILC on the other hand typically never requires more than a few dozen iterations to exceed human performance. But ILC typically requires reasonable models about the underlying system dynamics, and often assumes fairly well specified dynamics. Is there a middle ground here where we can specify a coarse model but still learn on actual physical systems in a short amount of time?</p>
<p>Understanding this tradeoff between modeling and number of required iterations is a fascinating practical and theoretical challenge. What new insights can be gleaned from comparing and contrasting classical control approaches with reinforcement learning techniques? How well do we need to understand a system in order to control it? In the next few posts, I’ll describe a variety of different approaches to the RL game and how different techniques choose to optimize inside of these rules. We’ll dive in with my least favorite of the bunch <a href="http://www.argmin.net/2018/02/20/reinforce/">Policy Gradient</a>.</p>
</article>